# Reverse Auth Flow (OAuth 2.0 Device Code Flow)

The Reverse Auth Flow (OAuth 2.0 Device Code Flow) is the professional standard for linking hardware like an ESP32 to a Flutter application. It is highly secure because the sensitive linking happens on the server, while the user only handles a simple, temporary code.

Below is the complete, detailed breakdown of the architecture, database schema, and the reverse flow enrollment workflow.

## 1. Architecture Overview

- Device (ESP32): Requests a pairing code from the server and displays it on its screen.
- App (Flutter): The authenticated user types the code shown on the device into their phone.
- Handshake: The device polls the server repeatedly. Once the server sees the user has entered the correct code in the app, it confirms the link to the device.
- Security: The device never sees the user's password. It receives a unique device secret from the server only after the human user has authorized the pairing.

## 2. Database Schema and Parameter Definitions

### A. Pairing Handshake Endpoint ("Meeting Point")

- Path: `/pending_codes/{device_code}`
- URL parameter `device_code`: A long, hidden unique string generated by the server for the ESP32 to use while polling.
- Fields:
  - `user_code`: The 6-character string (for example, `K9XJ22`) shown on the ESP32 screen.
  - `owner_uid`: Initially null, filled by the Flutter app when the user types the code.
  - `status`: `waiting` or `paired`.
  - `expires_at`: Timestamp (usually 5-10 minutes).

### B. Hardware Registry Endpoint

- Path: `/devices/{device_mac_address}`
- Fields: `owner_uid` (string), `device_secret` (generated by server or device).
- Purpose: The permanent record that says "This specific hardware belongs to this human."

### C. Telemetry Data Endpoint

- Path: `/crops/{associated_owner_uid}/readings/{reading_id}`
- Fields: `temp`, `humidity`, `timestamp`, `mac_address`, `device_secret`.
- Security: Firebase rules reject any write where the `device_secret` does not match the hardware registry record.

## 3. The Reverse Enrollment Workflow

### Step 1: ESP32 Initial Request

- The ESP32 connects to Wi-Fi and calls a server function: "I need a pairing code."
- The server generates a 6-character user code (for example, `AB12XY`) and a hidden device code.
- ESP32 return: The server sends both to the ESP32.
- ESP32 action: It displays `AB12XY` on its screen and begins polling the server every 5 seconds: "Has anyone entered AB12XY yet?"

### Step 2: Flutter App (The User)

- The user sees the code `AB12XY` on the device screen.
- They open the Flutter app and go to "Add Device."
- They type `AB12XY` into a simple text field and hit submit.
- Flutter action: The app sends a request to the server: "Current user (ID: 123) is claiming the device with code AB12XY."

### Step 3: The Server Match

- The server finds the entry for `AB12XY` and updates the `owner_uid` to `123`.
- It changes the status to `paired`.

### Step 4: Completion

- The next time the ESP32 polls, the server responds: "Success! You are now owned by user 123. Here is your permanent device secret."
- The ESP32 saves the `owner_uid` and device secret to its internal NVS (Non-Volatile Storage).

## 4. Security Rules (The Firewall)

Example Firebase rules:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 1. Only the linked owner can read the crop data
    match /crops/{uid}/readings/{doc} {
      allow read: if request.auth.uid == uid;

      // 2. Device must provide the correct secret to log data
      allow write: if request.resource.data.device_secret ==
        get(/databases/$(database)/documents/devices/$(request.resource.data.mac_address)).data.device_secret;
    }
  }
}
```

## 5. Why the Reverse Flow is the 2026 Professional Standard

- UX superiority: It is much easier for a human to type 6 letters into a smartphone keyboard than a small, laggy ESP32 virtual keyboard.
- Authentication safety: The ESP32 never handles the user's login credentials. It only receives a restricted token after the user confirms the code on their own trusted device.
- Industry standard: This is the exact protocol used by Apple TV, YouTube, and Netflix for hardware activation.
- No direct device-to-phone link: Since both talk to the server, you do not have to deal with the common failures of Bluetooth pairing or Wi-Fi Direct.
